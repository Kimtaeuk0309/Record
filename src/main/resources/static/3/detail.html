<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>개인 상세 기록</title>
    <style>
        table {
            border-collapse: collapse;
            width: 90%;
            max-width: 900px;
            margin: 20px auto;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f2f2f2;
        }
        h1, h2 {
            text-align: center;
        }
        .total-row {
            font-weight: bold;
            background-color: #e0e0e0;
        }
        #totalCountDisplay {
            text-align: center;
            font-weight: bold;
            margin-top: 20px;
        }
        #rankChart {
            max-width: 300px;
            margin: 20px auto;
            display: block;
        }
        #recentRankChart {
            max-width: 1200px;
            height: 350px;
            margin: 20px auto;
            padding-top: 20px;
            padding-bottom: 20px;
        }
        .yaku-img-preview {
            max-height: 50px;
            margin-left: 10px;
            vertical-align: middle;
            cursor: pointer;
            display: none;
        }
        .control-btn {
            margin-left: 10px;
            cursor: pointer;
            font-size: 0.9em;
            padding: 2px 6px;
        }
        #imgModal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0; top: 0;
            width: 100vw; height: 100vh;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        #imgModal img {
            max-width: 90%;
            max-height: 90%;
            box-shadow: 0 0 10px #fff;
        }
    </style>
</head>
<body>
<h1 id="nicknameTitle">개인 기록</h1>

<div id="totalCountDisplay">총국수: -</div>
<canvas id="rankChart"></canvas>

<canvas id="recentRankChart"></canvas>

<div>
    <h2>자리별 기록 통계</h2>
    <table>
        <thead>
        <tr>
            <th>자리</th>
            <th>출전 횟수</th>
            <th>1위 횟수</th>
            <th>2위 횟수</th>
            <th>3위 횟수</th>
            <th>4위 횟수</th>
            <th>1위 비율</th>
            <th>2위 비율</th>
            <th>3위 비율</th>
            <th>4위 비율</th>
        </tr>
        </thead>
        <tbody id="positionStatsBody"></tbody>
    </table>
</div>

<div style="max-width: 900px; margin: 20px auto;">
    <h2>역만 기록 목록</h2>
    <ul id="yakuListContainer" style="font-size: 0.9em; line-height: 1.4em; padding-left: 20px;"></ul>
</div>

<div id="imgModal">
    <img alt="확대 이미지" />
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="../js/common.js"></script>
<script src="../js/group.js"></script>
<script>
    async function loadDetail() {
        const urlParams = new URLSearchParams(window.location.search);
        const nickname = urlParams.get("nickname");
        if (!nickname) {
            alert("닉네임이 지정되지 않았습니다.");
            return;
        }
        document.getElementById("nicknameTitle").textContent = `${nickname}님의 상세 기록`;

        let totalCount = 0;
        try {
            const statsResp = await fetch('/api/statistics');
            if (!statsResp.ok) throw new Error('통계 데이터 불러오기 실패: ' + statsResp.status);
            const statsList = await statsResp.json();
            const stat = statsList.find(s => s.nickname === nickname);
            totalCount = stat ? stat.totalCount : 0;
        } catch (e) {
            alert('총국수 조회 중 오류가 발생했습니다.');
            console.error(e);
            totalCount = 0;
        }
        document.getElementById("totalCountDisplay").textContent = `총국수: ${totalCount}`;

        let resJson = null;
        let records = [];
        let yakuImageMap = {};
        try {
            const detailResp = await fetch(`/api/recordset/detail?nickname=${encodeURIComponent(nickname)}`);
            if (!detailResp.ok) {
                alert("상세 기록 조회 실패");
                return;
            }
            resJson = await detailResp.json();
            if (resJson.yakuImageMap) {
                yakuImageMap = resJson.yakuImageMap;
            }
            records = Array.isArray(resJson.records) ? resJson.records : [];
        } catch (e) {
            alert("상세 기록 조회 중 오류가 발생했습니다.");
            console.error(e);
            return;
        }

        if (!Array.isArray(records)) {
            alert("상세 기록 데이터가 배열이 아닙니다.");
            return;
        }

        const positionStats = {
            "동": { count: 0, ranks: [0, 0, 0, 0] },
            "남": { count: 0, ranks: [0, 0, 0, 0] },
            "서": { count: 0, ranks: [0, 0, 0, 0] },
            "북": { count: 0, ranks: [0, 0, 0, 0] }
        };
        records.forEach(rec => {
            if (!rec) return;
            if (rec.nickname === nickname && rec.direction && positionStats.hasOwnProperty(rec.direction)) {
                positionStats[rec.direction].count++;
                if (typeof rec.rank === "number" && rec.rank >= 1 && rec.rank <=4) {
                    positionStats[rec.direction].ranks[rec.rank -1]++;
                }
            }
        });

        const posStatsBody = document.getElementById("positionStatsBody");
        posStatsBody.innerHTML = "";

        for (const pos of ["동","남","서","북"]) {
            const stat = positionStats[pos];
            stat.count = stat.ranks.reduce((a,b) => a+b, 0);
        }

        const totalRanks = [0, 0, 0, 0];
        let totalPositionsCount = 0;
        Object.values(positionStats).forEach(stat => {
            totalPositionsCount += stat.count;
            for(let i=0; i<4; i++) {
                totalRanks[i] += stat.ranks[i];
            }
        });

        const rankPercentages = totalPositionsCount ? totalRanks.map(r => (r/totalPositionsCount)*100) : [0,0,0,0];
        const ctx = document.getElementById('rankChart').getContext('2d');
        if(window.rankChartInstance) {
            window.rankChartInstance.destroy();
        }
        window.rankChartInstance = new Chart(ctx,{
            type:'doughnut',
            data:{
                labels:['1위','2위','3위','4위'],
                datasets:[{
                    data: rankPercentages,
                    backgroundColor: ['#4CAF50', '#2196F3', '#FFC107', '#F44336'],
                    hoverOffset: 30,
                }]
            },
            options:{
                responsive:true,
                plugins:{
                    legend: {position:'bottom'},
                    tooltip: {
                        callbacks: {
                            label: ctx => `${ctx.label}: ${ctx.parsed.toFixed(1)}%`
                        }
                    }
                }
            }
        });

        const totalTr = document.createElement("tr");
        totalTr.classList.add("total-row");
        totalTr.innerHTML = `
            <td>합계</td>
            <td>${totalPositionsCount}</td>
            <td>${totalRanks[0]}</td>
            <td>${totalRanks[1]}</td>
            <td>${totalRanks[2]}</td>
            <td>${totalRanks[3]}</td>
            <td>${totalPositionsCount ? ((totalRanks[0]/totalPositionsCount)*100).toFixed(1) : '0.0'}%</td>
            <td>${totalPositionsCount ? ((totalRanks[1]/totalPositionsCount)*100).toFixed(1) : '0.0'}%</td>
            <td>${totalPositionsCount ? ((totalRanks[2]/totalPositionsCount)*100).toFixed(1) : '0.0'}%</td>
            <td>${totalPositionsCount ? ((totalRanks[3]/totalPositionsCount)*100).toFixed(1) : '0.0'}%</td>
        `;
        posStatsBody.appendChild(totalTr);

        for (const pos of ["동","남","서","북"]) {
            const stat = positionStats[pos];
            const tr = document.createElement("tr");
            tr.innerHTML = `
                <td>${pos}</td>
                <td>${stat.count}</td>
                <td>${stat.ranks[0]}</td>
                <td>${stat.ranks[1]}</td>
                <td>${stat.ranks[2]}</td>
                <td>${stat.ranks[3]}</td>
                <td>${stat.count ? ((stat.ranks[0]/stat.count)*100).toFixed(1) : '0.0'}%</td>
                <td>${stat.count ? ((stat.ranks[1]/stat.count)*100).toFixed(1) : '0.0'}%</td>
                <td>${stat.count ? ((stat.ranks[2]/stat.count)*100).toFixed(1) : '0.0'}%</td>
                <td>${stat.count ? ((stat.ranks[3]/stat.count)*100).toFixed(1) : '0.0'}%</td>
            `;
            posStatsBody.appendChild(tr);
        }

        // 최근 20전 순위 그래프
        const recentRecords = records
            .filter(r => r.nickname === nickname && typeof r.rank === "number" && r.rank >= 1 && r.rank <= 4)
            .slice(0,20);

        recentRecords.reverse();

        const rankColor = ['#4CAF50', '#2196F3', '#FFC107', '#F44336'];

        const recentRanks = recentRecords.map(r => r.rank);
        const recentLabels = recentRecords.map(() => '');
        const recentPointColors = recentRanks.map(rank => rankColor[rank - 1]);

        const recentCtx = document.getElementById('recentRankChart').getContext('2d');
        if(window.recentRankChartInstance) {
            window.recentRankChartInstance.destroy();
        }
        window.recentRankChartInstance = new Chart(recentCtx, {
            type: 'line',
            data: {
                labels: recentLabels,
                datasets: [{
                    label: '최근 20전 순위',
                    data: recentRanks,
                    fill: false,
                    borderColor: '#D3D3D3',
                    backgroundColor: '#1976D2',
                    tension: 0.2,
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    pointBackgroundColor: recentPointColors
                }]
            },
            options: {
                responsive: true,
                layout: {
                    padding: {
                        top: 20,
                        bottom: 20
                    }
                },
                scales: {
                    y: {
                        title: {
                          display: true,
                          text: '순위'
                        },
                        reverse: true,
                        min: 0.5,
                        max: 4.5,
                        ticks: {
                            stepSize: 0.5,
                            callback: function(value) {
                                if (value === 0.5 || value === 1.5 || value === 2.5 || value === 3.5 || value === 4.5 ) return ''; // 0위, 5위는 라벨 숨김
                                return value + '위';
                            }
                        },
                        grid: {
                            display: false
                        }
                    },
                    x: {
                        title: {
                            display: true
                        },
                        ticks: {
                            display: false
                        },
                        grid: {
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const idx = context.dataIndex;
                                const rec = recentRecords[idx];
                                const isMine = rec.nickname === nickname;

                                let result = `[${rec.rank}위] [${rec.nickname}] [${rec.direction}] [${rec.score}]`;
                                if (isMine) {
                                    result = `${result}`;
                                    }
                                return result;
                            }
                        }
                    }
                }
            }
        });

        // 역만 기록 목록 처리
const yakuListContainer = document.getElementById("yakuListContainer");
yakuListContainer.innerHTML = '';

const yakuEntries = [];
const globalTimestamp = (resJson && resJson.timestamp) ? resJson.timestamp.substring(0,10) : '날짜 없음';

records.forEach(rec => {
    if(!rec) return;
    if(rec.nickname === nickname && Array.isArray(rec.yakuList) && rec.yakuList.length > 0) {
        const dateStr = (rec.timestamp && rec.timestamp.length >= 10) ? rec.timestamp.substring(0,10) : globalTimestamp;
        rec.yakuList.forEach(yaku => {
            yakuEntries.push({ date: dateStr, yaku });
        });
    }
});

yakuEntries.sort((a,b) => a.date.localeCompare(b.date));

if(yakuEntries.length === 0) {
    yakuListContainer.textContent = '역만 기록이 없습니다.';
} else {
    yakuEntries.forEach(entry => {
        const li = document.createElement('li');
        li.textContent = `${entry.date} / ${entry.yaku} `;

        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.style.marginLeft = '10px';
        fileInput.style.display = 'inline-block';

        const imgPreview = document.createElement('img');
        imgPreview.className = 'yaku-img-preview';

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '삭제';
        deleteBtn.className = 'control-btn';
        deleteBtn.style.display = 'none';

        const savedImageUrl = yakuImageMap[entry.yaku];
        if(savedImageUrl) {
            imgPreview.src = savedImageUrl;
            imgPreview.style.display = 'inline-block';
            fileInput.style.display = 'none';
            deleteBtn.style.display = 'inline-block';
        }

        fileInput.addEventListener('change', async () => {
            const file = fileInput.files[0];
            if(file) {
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('nickname', nickname);
                    formData.append('yaku', entry.yaku);

                    const uploadResp = await authFetch('/api/uploadYakuImage', {
                        method: 'POST',
                        body: formData
                    });
                    if (!uploadResp.ok) throw new Error('업로드 실패');

                    const data = await uploadResp.json();
                    if (data.url) {
                        imgPreview.src = data.url;
                        imgPreview.style.display = 'inline-block';
                        deleteBtn.style.display = 'inline-block';
                        fileInput.style.display = 'none';
                    }
                } catch (e) {
                    alert('업로드 중 오류가 발생했습니다: ' + e.message);
                    fileInput.value = '';
                }
            } else {
                imgPreview.style.display = 'none';
                fileInput.style.display = 'inline-block';
                deleteBtn.style.display = 'none';
            }
        });

        imgPreview.style.cursor = 'pointer';
        imgPreview.addEventListener('click', () => {
            if (imgPreview.style.display !== 'none' && imgPreview.src) {
                modalImg.src = imgPreview.src;
                imgModal.style.display = 'flex';
            }
        });

        deleteBtn.addEventListener('click', async () => {
            if(confirm('정말 업로드한 사진을 삭제하시겠습니까?')) {
                try {
                    const resp = await authFetch(`/api/deleteYakuImage?nickname=${encodeURIComponent(nickname)}&yaku=${encodeURIComponent(entry.yaku)}`, {
                        method: 'DELETE',
                    });
                    if (!resp.ok) throw new Error('서버 삭제 실패');

                    imgPreview.style.display = 'none';
                    imgPreview.src = '';
                    fileInput.value = '';
                    fileInput.style.display = 'inline-block';
                    deleteBtn.style.display = 'none';
                } catch(e) {
                    alert('삭제 중 오류가 발생했습니다: ' + e.message);
                }
            }
        });

        li.appendChild(fileInput);
        li.appendChild(imgPreview);
        li.appendChild(deleteBtn);

        yakuListContainer.appendChild(li);
    });
}

    }

    const imgModal = document.getElementById('imgModal');
    const modalImg = imgModal.querySelector('img');

    imgModal.addEventListener('click', () => {
        imgModal.style.display = 'none';
        modalImg.src = '';
    });

    window.onload = loadDetail;
</script>
</body>
</html>
